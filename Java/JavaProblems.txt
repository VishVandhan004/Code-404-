                                                ***********  1st Problem   ***********
Given an list of decimal numbers and an desired number, return the twin values in a such that their sum equals the desired number..
You can make the assumption that every input has exactly one answer, and you can avoid using the same element more than once.
4
1 8 11 15
target:9
0,1

#include<stdio.h> 
int main() 
{ 
    int i,values,target,n; 
    int arr[10]; 
    printf("enter the number of values:\n"); 
    scanf("%d",&n); 
    printf("enter the values:\n"); 
    for(int i=0; i<n; i++) 
    { 
        scanf("%d",&arr[i]); 
    } 
    printf("enter the target: \n"); 
    scanf("%d",&target); 
    for(int i=0; i<n; i++) 
    { 
        for(int j=i+1; j<n; j++) 
        { 
            if(arr[i] + arr[j]==target) 
            { 
                printf("%d,%d",i,j); 
            } 
        } 
    } 
}

                                                    *********** 2nd problem ************
/*Take three persons age from the user and print the Oldest Person out of three persons using Nested if. 
Enter the 1st person age: 25 
Enter the 2nd person age: 78 
Enter the 3rd person age: 87 
Expected Output : 
The oldest person is: 87 
*/ 
import java.util.*; 
class test{ 
    public static void main(String args[]) 
    { 
        int n,a,b,c; 
        Scanner sc=new Scanner(System.in); 
        System.out.print("Enter the 1st person age: "); 
        a = sc.nextInt(); 
        System.out.print("Enter the 2nd person age: "); 
        b=sc.nextInt(); 
        System.out.print("Enter the 3rd person age: "); 
        c=sc.nextInt(); 
        if(a>b) 
        { 
            if(a>c) 
            { 
                System.out.printf("The oldest person is %d",a); 
            } 
            else{ 
                System.out.printf("The oldest person is %d",c); 
            } 
        } 
        else { 
            System.out.printf("The oldest person is %d",b); 
          } 
        }  
    }

                                 ************* 3rd Problem   **************
/*Write a Java program that takes a year from user and print whether that year is a leap year or not.
Enter the year: 2016
2016 is a leap year
*/

import java.util.*;
class test {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the year: ");
        int y = sc.nextInt();
                if(y%4==0)
                {
                    System.out.printf("%d is a leap year",y);
                }
    }
}
                                   ************** 4th Problem **************
/*take the different size of balls in array and find the second largest ball in array
Enter number of the balls: 5 
Enter balls with different sizes: 
2 3 7 6 9
Second largest ball = 7*/

import java.util.*;
class test
{
    public static void main(String args[]){
        int n;
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter number of the balls: ");
        n = sc.nextInt();
        int []arr = new int[n];
        System.out.println("Enter balls with different sizes:");
        for(int i=0;i<n;i++)
        {
            arr[i] = sc.nextInt();
        }
        for(int i=0;i<n-1;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(arr[i]>arr[j])
                {
                int temp;
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                }
            }
        }
        System.out.printf("Second largest ball = %d",arr[n-2]);
    }
}
                               ************** 5th Problem *****************
In a theatre there are M rows and N seats in each row. The seats are numbered in a strange order (No duplicates). 
You need to find out the total sum of the seat numbers which are maximum in their columns. 
Input Format: 
Line-1 -> Two integers M and N 
Next M lines -> N space separated integers, seat numbers. 
Output Format: 
Print an integer result. 
Sample Input-1: 
3 3 
3 7 18 
9 16 13 
15 11 17 
Sample Output-1: 
49 
Sample Input-2: 
3 4 
1 10 4 2 
9 3 18 17 
15 16 17 12 
Sample Output-2: 
66

#include<stdio.h>
int main(){
    int i,j,r,c,sum=0;
    scanf("%d %d",&r,&c);
    int arr[r][c];
    for(i=0;i<r;i++){
        for(j=0;j<c;j++){
        scanf("%d",&arr[i][j]);
        }
    }
    for(j=0;j<c;j++)
    {
      int max = arr[0][0];
     for(i=0;i<r;i++)
        {
            if(arr[i][j] > max){
                max = arr[i][j];
            }
        }
            sum = sum+max;
    }
    printf("%d",sum);
}                     
                                  ***************** 6th Problem *****************
/* 
Given a string S in encoded form, and  an integer array indices[] of string length. You need to find the decoded form of String S,  
by moving each character at ith position in S, to indices[i] position in decoded string.and then print the decoded string. 
Input Format: 
Line-1 -> A String S, enocded string of length L 
Line-2 -> L space separated integers indices[], where 0 <=indices[i] < L  
Output Format: 
Print a String, decoded string. 
Sample Input-1: 
aeilmmor 
6 1 5 7 2 0 3 4 
Sample Output-1: 
memorial 
Explanation: 
Given String, 
aeilmmor 
6 1 5 7 2 0 3 4 
after shifting,	memorial 
Sample Input-2: 
aidin 
4 3 2 0 1 
Sample Output-2: 
india 
Explanation-2: 
Given String,
aidin 
4 3 2 0 1 
after shifting,	india 
*/

#include<stdio.h>
#include<string.h>
int main()
{
    char str[30];
    char str1[30];
    int i;
    scanf("%s",str);
    int arr[strlen(str)];
    for(int i=0;i<strlen(str);i++){
       scanf("%d",&arr[i]);
    }
    int j=0;
    for(int i=0;i<strlen(str);i++){
        j=arr[i];
        str1[j]=str[i];
    }
    for(i=0;i<strlen(str);i++){
        printf("%c",str1[i]);
    }
}

                                    **************** 7th Problem *******************
Given an integer array nums, find the  subarray  with the largest sum, and return its sum.
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.                    

class Solution {
    public int maxSubArray(int[] nums) {
     Scanner sc = new Scanner(System.in);
        int max_S = nums[0];
        int current_S = nums[0];
        for(int i=1;i<nums.length;i++)
        {
                current_S = Math.max(nums[i],current_S+nums[i]);
                max_S = Math.max(max_S,current_S);
        }
       return max_S;
    }
}
                           ****************** 8th Problem ******************
/*Bob given a task to Babe, i.e, Babe has to detect unique value in a given set of values by Bob
input=
8
12 25 8 12 43 5 8 43
output=
25 5
*/

#include<stdio.h>
int main() {
    int arr[20];
    int n,i,j;
    scanf("%d",&n);
    for(i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    for(i=0;i<n;i++){
        int count=0;
        for(j=0;j<n;j++){
            if(i!=j){
                if(arr[i] == arr[j]){
                    count++;
                }
            }
        }
        if(count==0){
            printf("%d ",arr[i]);
        }
    }
}                           
                      *********************** 9th Problem ************************
/*
Java Program To Calculate The Sum Of Array Elements By Taking Input Values from user
Enter number of elements: 5
Enter array elements:
10 20 30 40 50
Sum of array elements= 150
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter number of elements:");
        int n = sc.nextInt();
        int sum = 0;
        System.out.println("Enter array elements: ");
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        for(int i=0;i<n;i++){
            sum = sum + arr[i];
        }
        System.out.print("Sum of array elements = "+ sum);
    }
}
                              ************************** 10th Problem *************************
/*read rows and colums of first and second matrix, then read elements into both matrix,perform addition of those two matrix and dispaly first,second and result matrix. 
input: 
2 
2 
2 
2 
1 
2 
3 
4 
1 
2 
3 
4 
output: 
1 2 
3 4 
1 2 
3 4 
2 4 
6 8 
input= 
2 
3 
2 
2 
output= 
Addition would not be possible 
*/ 
import java.util.*; 
class test 
{ 
    public static void main(String args[]) 
    { 
       Scanner sc = new Scanner(System.in); 
       int row1 = sc.nextInt(); 
       int col1 = sc.nextInt(); 
       int row2 = sc.nextInt(); 
       int col2 = sc.nextInt(); 
     if(row1!=row2 || col1!=col2) 
     { 
         System.out.println("Addition would not be possible"); 
         System.exit(0); 
     } 
       int a1[][] = new int[row1][col1]; 
       int a2[][] = new int[row2][col2]; 
       for(int i=0;i<row1;i++){ 
           for(int j=0;j<col1;j++){ 
               a1[i][j] = sc.nextInt(); 
           } 
       } 
       for(int i=0;i<row2;i++){ 
           for(int j=0;j<col2;j++){ 
               a2[i][j] = sc.nextInt(); 
           } 
       } 
       for(int i=0;i<row1;i++){ 
           for(int j=0;j<col1;j++){ 
               System.out.print(a1[i][j] + " "); 
           } 
           System.out.println(); 
       } 
       for(int i=0;i<row2;i++){ 
           for(int j=0;j<col2;j++){ 
               System.out.print(a2[i][j] + " "); 
           } 
               System.out.println(); 
       } 
     if(row1 == row2 && col1 == col2) 
     { 
       for(int i=0;i<row1;i++){ 
           for(int j=0;j<col1;j++){ 
               System.out.println(a2[i][j] + a1[i][j]); 
           } 
       } 
     } 
        
   } 
}                   
                                ****************** 11th Problem ********************
/* Wrie a Java program  that will test if a string is a valid PIN or not 
A valid PIN has: Exactly 4 or 6 characters. Only numeric characters (0-9). No whitespace.
121317
true
45135
false
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String PIN = sc.nextLine();
        int len = PIN.length();
        if(len !=4 && len != 6 ) {
            System.out.println("false");
            return;
        }
        for(int i=0;i<len;i++)
        {
            int temp = (int)PIN.charAt(i);
            if(!(temp>=48) || !(temp<=57))
            {
                System.out.println("False");
                return;
            }
        }
        System.out.println("True");

    }
}

                              ********************** 12th Problem *********************
/*
Cliff Shaw is working on the singly linked list. He is given a list of boxes arranged as singly linked list, where each box is printed with a positive number on it and arranged in the list are ascending order. and numbers on the boxes may be repeated.
Mr Cliff Shaw is performing an operation on the list. To have only the distinct values in the final list, removed all duplicate values.
Your task is to help Mr Cliff to perform the operation and return the updated list
Input Format:
Line-1: An integer, N number of boxes in list.
Line-2: N space separated integers, boxes as list.
Output Format:
Print the updated list.
Sample Input-1:
8
1 1 1 2 2 3 3 4
Sample Output-1:
1 2 3 4
Sample Input-2:
5
1 1 1 1 1
Sample Output-2:
1

import java.util.*;
class test {
    public static void main(String args[]){
        LinkedList<Integer> ll = new LinkedList<Integer>();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 0;i<n;i++){
        int e = sc.nextInt();
        ll.add(e);
        }
        LinkedList<Integer> newlist = new LinkedList<Integer>();
        for(Integer ele:ll){
            if(!newlist.contains(ele)) {
                newlist.add(ele);
            }
        }
        System.out.print(newlist);
    }
}
                               ********************* 13th Problem *********************
/*
Cliff Shaw is working on the singly linked list. He is given a list of boxes arranged as singly linked list, where each box is 
printed with a positive number on it and arranged in the list are ascending order. and numbers on the boxes may be repeated.
Mr Cliff Shaw is performing an operation on the list. To have only the distinct values in the final list, removed all duplicate values.
Your task is to help Mr Cliff to perform the operation and return the updated list
Input Format:
Line-1: An integer, N number of boxes in list.
Line-2: N space separated integers, boxes as list.
Output Format:
Print the updated list.
Sample Input-1:
8
1 1 1 2 2 3 3 4
Sample Output-1:
1 2 3 4
Sample Input-2:
5
1 1 1 1 1
Sample Output-2:
1

import java.util.*;
class test {
    public static void main(String args[]){
        LinkedList<Integer> ll = new LinkedList<Integer>();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 0;i<n;i++){
        int e = sc.nextInt();
        ll.add(e);
        }
        LinkedList<Integer> newlist = new LinkedList<Integer>();
        for(Integer ele:ll){
            if(!newlist.contains(ele)) {
                newlist.add(ele);
            }
        }
        System.out.print(newlist);
    }
}
                                ********************** 14th Problem ********************
/*
There is a railway route from Vizag to Hyderabad.The stations in the route will be identified by the codes(may be repeated).
You will be given the list of station codes, using singly linked list implementation find the middle station in the given route.
If there are even number of stations, print the second middle station. Your task is to find the middle station code in the given train route.
NOTE: You shoud pass only the head node to the method/function to find the middle station in that route.
Input Format:
Line-1: space separated integers, station codes.
Output Format:
Print an integer, middle station code.
Sample Input-1:
5
1 2 3 4 5
Sample Output-1:
3
Sample Input-2:
6
1 2 3 4 5 6
Sample Output-2:
4
Explanation:
We have even number of stations, so the second middle station is 4

import java.util.*;
class test
{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        LinkedList<Integer> ll = new LinkedList <Integer> ();
        for(int i=0;i<a;i++){
            int b = sc.nextInt();
            ll.add(b);
        }
        int half = a/2;
        System.out.println(ll.get(half));
    }
}                                
                                       **************** 15th Problem ***************
/*Ram is playing a game of identifying the pairs of numbers from the givenlist of numbers. Help Ram to identify the number of pairs which satisfy the following criteria list[i]=list[j] and i<j
Example 1:
Input:6
1 2 3 1 1 3
Output: 4
Explanation: There are 4 pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Example 2:
Input:4
1 1 1 1
Output: 6
Explanation: Each pair in the array are satisfying the given constraint.
Example 3:
Input:3
1,2,3
Output: 0
Explanation: The array does not have any element that are equal to each other.
*/

import java.util.*;
class test{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int a,b;
        int arr[] = new int[num];
        for(a=0;a<num;a++){
            arr[a] = sc.nextInt();
        }
        int count = 0;
        for(a=0;a<num;a++){
            for(b=a+1;b<num;b++){
                if(arr[a] == arr[b]){
                    count++;
                }
            }
        }
        System.out.println(count);
        
    }
}                      
                                          ************************* 16th Problem ***********************
/*Given an list of numbers, return the highest common factor of the smallest number and bigest number in list. The highest common factor of two numbers is the biggest positive number that evenly divides both numbers. 
Input: numberss = 2 9 6 5 12 
Output: 2 
Explanation: 
The smallest number in list is 2. 
The largest number in list is 12. 
The highest common factor of 2 and 12 is 2. 
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
       Scanner sc = new Scanner(System.in);
       try 
       {
           
        String str = sc.nextLine();
        String[] stArr = str.split(" ");
        int len = stArr.length;
        int[] arr = new int[len];
        for(int i=0;i<len;i++){
           int n = Integer.parseInt(stArr[i]);
           arr[i] = n;
       }
       Arrays.sort(arr);
        int min = arr[0];
        int max = arr[len-1];
        int HCF = 0;
        for(int i=1;i<=min || i<= max ;i++){
            if(min%i == 0 && max%i == 0){
                HCF = i;
            }
        }
        System.out.println(HCF);
    }
       finally {
           
           sc.close();
       }
   }
}                
                                         *********************** 17th problem ***********************
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.
You must write an algorithm with O(log n) runtime complexity.                     
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

class Solution {
    public int search(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] >= nums[low]) { // left half is sorted
                if (target >= nums[low] && target < nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else { // right half is sorted
                if (target <= nums[high] && target > nums[mid]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
}
                                                ********** 18th Problem  ************
Given an array of N integers where each value represents the number of chocolates in a packet. Each packet can have a variable number of chocolates. There are m students, the task is to distribute chocolate packets such that: 
Each student gets one packet.
The difference between the number of chocolates in the packet with maximum chocolates and the packet with minimum chocolates given to the students is minimum.
Examples:
Input : arr[] = {7, 3, 2, 4, 9, 12, 56} , m = 3 
Output: Minimum Difference is 2 
Explanation:
We have seven packets of chocolates and we need to pick three packets for 3 students 
If we pick 2, 3 and 4, we get the minimum difference between maximum and minimum packet sizes.
Input : arr[] = {3, 4, 1, 9, 56, 7, 9, 12} , m = 5 
Output: Minimum Difference is 6 

import java.util.*;
public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the size of an array:");
        int n = sc.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println("Enter the no.of students");
        int m = sc.nextInt();
        Arrays.sort(arr);
        int min =Integer.MAX_VALUE;
        for(int i=0;i<=n-m;i++)
        {
            int diff = arr[i+m-1] - arr[i];
            if(diff<min)
            {
                min = diff;
            }
        }
        System.out.printf("Difference is %d",min);
    }
}
                            ***************** 19th Problem ********************
/*You have given N bricks. You need to construct a staircase as follows: 
1. = 
2. == 
3. === 
4. ==== 
Where = indicates one brick. 
Another condition is row-1 should have 1 brick, row-2 should have 2 bricks and so on.i.e., i-th row should have 'i' bricks. 
Your task is to findout total number of staircases can be formed with the given condition. 
Input Format: 
 An integer N 
Output Format: 
Print an integers, number of staircases 
Sample Input-1: 
 5 
Sample Output-1: 
2 
Explanation: 
row-1:	= 
row-2:	== 
row-3:	== 
Only 2 rows satisfies the condition. 
Sample Input-2: 
 8 
Sample Output-2: 
3 
Explanation: 
row-1:	= 
row-2:	== 
row-3:	=== 
row-4:	== 
Only 3 rows satisfies the condition. 
*/

import java.util.*;
class test {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt();
        int i=0;
        int count = 0;;
        for(i=1;i<=row;i++){
            int bricks = (i*(i+1))/2;
            if(bricks>row){
                break;
            }
            else {
                count++;
            }
        }
        System.out.print(count);
    }
}
or 
import java.util.*;
class test 
{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt();
        int i=1;
        int count = 0;
        while(row>=i){
            row = row - i;
            i++;
            count++;
        }
        System.out.print(count);
    }
}    
                                            ****************************** 20th Problem ************************        
/*Ranga rao sir asked a student to find duration among Mid1 and Mid2 exam dates. read both dates in string format, i.e, year-month-date as given in sample data. 
input: 
"2020-06-28" 
"2020-06-29" 
output:1 
Input:  
"2019-01-14" 
"2018-12-30" 
Output: 15 
*/

import java.util.*;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
class test
{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String s1 = sc.nextLine();
        String s2 = sc.nextLine();
        LocalDate a1 = LocalDate.parse(s1);
        LocalDate a2 = LocalDate.parse(s2);
        long dura = ChronoUnit.DAYS.between(a1,a2);
        System.out.println(dura);
    }
}             
                                    ***************************** 21st Problem ************************
/*Given a word w, rotate other than consonents in the word and print it. 
The other than consonents are 'i', 'a', 'u', 'e', and 'e', and they can be seen in both lower- and uppercase,More than once. 
Input: 
"ravi" 
Output: 
"riva" 
sample 2: 
Input:  
"telusuko" 
Output:  
"tolusuke" 
*/

import java.util.*;
class test {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char [] charArr = str.toCharArray();
        int len = charArr.length;
        for(int i=0;i<len;i++)
        {
          for(int j=i+1; j<len;j++)
          {
            char ch = charArr[i];
    if(ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u')
          {
            char d = charArr[j];
            if(d =='a'|| d=='e'||d=='i'||d=='o'||d=='u'){
                char temp = charArr[i];
                charArr[i] = charArr[j];
                charArr[j] = temp;
            }
          }
        }
      }
      String s1 = new String(charArr);
      System.out.println(s1);
   }
}         
                                   **************************** 22nd Problem ************************
/*There is a List L that consists of n only positive numbers. 
It was converted into another List L i.e, of length n - 1, such that coverted[i] = List[i] XOR List[i + 1]. For example, if List= [1,0,2,1], then converted= [1,2,3]. 
You are given the converted list. You are also given an start number, i.e. List[0].Return the original List L. It can be proved that the answer exists and is unique. 
Sample Data:  
input: 
1 2 3 
1 
output: 
1 0 2 1 
Explanation:  
If List= 1 0 2 1 then 1 and converted= (1 XOR 0, 0 XOR 2, 2 XOR 1) = 1 2 3*/

import java.util.*;
class test{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String [] numberString = s.split(" ");
        int len = numberString.length;
        int arr[] = new int[len];
        for(int i=0;i<len;i++){
            arr[i] = Integer.parseInt(numberString[i]);
        }
        System.out.print("start= ");
        int a = sc.nextInt();
        System.out.print(a+" ");
        for(int i=0;i<len;i++){
            a = a^arr[i];
            System.out.print(a+" ");
        }
    }
}        
                                   ************************ 23rd Problem *****************************
We use the integers , , and  to create the following series:
(a+ 2°*b),(a+2°*b+2^1*b),...,(a+2°*b4+2)-b+...+277 -b)
You are given queries. For each query, print the series corresponding to the given , , and  values as a single line of  space-separated integers. 
Input Format 
The first line contains an integer, , denoting the number of queries. 
Each line  of the  subsequent lines contains three space-separated integers describing the respective , , and  values for that query. 
Constraints 
Output Format 
For each query, print the corresponding series on a new line. Each series must be printed in order as a single line of  space-separated integers. 
Sample Input 
2 
0 2 10 
5 3 5 
Sample Output 
2 6 14 30 62 126 254 510 1022 2046 
8 14 26 50 98

import java.util.*; 
class Solution{ 
    public static void main(String []argh){ 
        Scanner in = new Scanner(System.in); 
        int t=in.nextInt(); 
        for(int i=0;i<t;i++){ 
            int a = in.nextInt(); 
            int b = in.nextInt(); 
            int n = in.nextInt(); 
            int sum = a; 
            for(int j=0;j<n;j++) 
            { 
            sum += Math.pow(2,j) * b;  
            System.out.print(sum + " "); 
            } 
            System.out.println(); 
        } 
        in.close(); 
    } 
}             
                      ************************************** 24th problem *************************************
Project school exam being conducted
Exam_starttime and exam_endtime of the student is given in two arrays. pse_strattime[i] indicates the project school exam start time of student i,
pse_endtime[i] indicates the project school end time of student i.Project school incharge wants to know the number of students writing the exam at given time. 
we can say a student is writing exam if given_time is between pse_startTime[i] and pse_endTime[i] inclusive.
Example 1:
Input: pse_startTime = [1,2,3], pse_endtime = [3,2,7], queryTime = 4
Output: 1
Explanation: We have 3 students where:
The first student started writing his exam at time 1 and finished at time 3 and wasn't doing anything at time 4.
The second student started writing his exam at time 2 and finished at time 2 and also wasn't doing anything at time 4.
The third student started writing his exam at time 3 and finished at time 7 and was the only student doing homework at time 4.
Example 2:
Input: startTime = [4], endTime = [4], queryTime = 4
Output: 1
Explanation: The only student writing his exam at the queryTime.
Test Cases:
Case=1
input=1 2 3
3 2 7
4
output=1
Case=2
input=4
4
4
output=1

import java.util.*;
class test
{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String startTime = sc.nextLine();
        String endTime = sc.nextLine();
        String arr1[] = startTime.split(" ");
        String arr2[] = endTime.split(" ");
        int queryTime = sc.nextInt();
        int count = 0;
        int len = arr1.length;
        int newarr1[] = new int[len];
        int newarr2[] = new int[len];
        for(int i=0;i<len;i++)
        {
            newarr1[i] = Integer.parseInt(arr1[i]);
            newarr2[i] = Integer.parseInt(arr2[i]);
           if(newarr1[i] <= queryTime && newarr2[i] >= queryTime)
          {
            count++;
          }
          
        }
        System.out.println(count);
    }
}            
                                        ******************* 25th Problem ***********************
Komali has n chocolates, where the ith chocolates is of type chocoType[i]. 
Komali mother noticed that komali started to gain weight, so she restricted Komali to only eat n / 2 of the chocolates she has. 
Komali likes her candies very much, and she wants to eat the maximum number of different types of chocolates while still following her mother's order.
Given the integer array chocoType of length n, return the maximum number of different types of chocolates she can eat if she only eats n / 2 of them.
Example 1:
Input: chocoType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 chocolates. Since there are only 3 types, she can eat one of each type.
Example 2:
Input: chocoType = [1,1,2,2,3]
Output: 2
Explanation: Alice can only eat 5 / 2 = 2(eating half chocolate is not allowed) chocolates. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
Example 3:
Input: chocoType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 chocolates. Even though she can eat 2 candies, she only has 1 type.
case=1
input= 2 2 2 3 3 3
output=2

import java.util.*;
class test 
{
    public static void main(String args[]){
       Scanner sc = new Scanner(System.in);
       String str = sc.nextLine();
       String arr[] = str.split(" ");
       int len = arr.length;
       int nums[] = new int[len+1];
       int count=0;
       for(int i=0;i<len;i++){
           nums[i] = Integer.parseInt(arr[i]);
       }
       for(int i=0; i<len; i++)
       {
           if(nums[i] != nums[i+1])
            {
                 count++;
             }
       }
       if(len/2>= count)
       System.out.print(count);
        if(len/2<count)
        System.out.print(len/2);
    }
}                
                                  **************************** 26th Problem *************************
Given a list of non-negative numbers, identify all the sublists of odd size from it, calculate the total of all the elements of sublists. 
Example 1:
Input: list = [1,4,2,5,3]
Output: 58
Explanation: The odd-size sublists of list and their sums are:
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
Example 2:
Input: list = [1,2]
Output: 3
Explanation: There are only 2 sublists of odd size, [1] and [2]. Their sum is 3.
Example 3:
Input: list = [10,11,12]
Output: 66
Case=1
input=1 4 2 5 3
output=58

import java.util.*;
class test {
    public static void main(String args[]){
     Scanner sc = new Scanner(System.in);
     String arr[] = sc.nextLine().split(" ");
     int length = arr.length;
     int[] Nlist = new int[length];
     int sum1 = 0;
     for(int i=0;i<length;i++){
         Nlist[i] = Integer.parseInt(arr[i]);
     }
     for(int i=0;i<length;i++){
         for(int j=i;j<length;j=j+2){
             for(int k=i;k<=j;k++){
                 sum1 = sum1 + Nlist[k];
             }
         }
     }
     System.out.println(sum1);
    }
}
                                    *************************** 27th Problem ***************************
There are n_coke bottles that are initially full of coke. You can exchange n_exchange empty coke bottles from the market with one full coke bottle.
The operation of drinking a full coke bottle turns it into an empty bottle.
Given the two integers n_coke and n_exchange, return the maximum number of coke bottles you can drink.
Example 1:
Input: no_coke= 9, n_exchange= 3
Output: 13
Explanation: You can exchange 3 empty coke bottles to get 1 full coke bottle.
Number of coke bottles you can drink: 9 + 3 + 1 = 13.
Example 2:
Input: no_coke = 15, n_exchange= 4
Output: 19
Explanation: You can exchange 4 empty coke bottles to get 1 full coke bottle. 
Number of coke bottles you can drink: 15 + 3 + 1 = 19.
Test cases:
case=1
input=15
4

import java.util.*;
class test {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int total = sc.nextInt();
        int exchange = sc.nextInt();
        int count = total;
        while(total >= exchange){
            count = count+total/exchange;
            total = total/exchange + total%exchange;
        }
        System.out.print(count);
    }
}    
                                   *************************** 28th Problem ***************************
A string is given, find the number of substrings of size 4 without repetitive characters. if the substring is appearing for multiple times, each one should be counted seperately
A substring is always a contiguous sequence of characters from the string.
Example 1:
I/p: s = "aabcdcdbe"
Output: 2
Explanation: There are 6 substrings of size 4: "aabc", "abcd", "bcdc", "cdcd","dcdb", and "cdbe". 
The substrings with given criteria are: "abcd", "cdbe".
Example 2:
I/p: s = "abcdabcd"
Output: 5
Explanation: There are 5 substrings of size 4: "abcd","bcda","cdab","dabc", "abcd". 
The substrings with given criteria are: "abcd","bcda","cdab","dabc", "abcd"
Test cases:
case=1
input=aabcdcdbe
output=2

import java.util.*;
class test {
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int length = str.length();
        int count=0;
        for(int i=0;i<length-3;i++)
        {
            boolean[] visited = new boolean[26];
            boolean isUnique = true;
            for(int j=i;j<i+4;j++)
            {
                if(visited[str.charAt(j) - 'a' ])
                {
                 isUnique = false;
                 break;
                }
              visited[str.charAt(j) - 'a'] = true;
            }
            if(isUnique)
            {
                System.out.println(str.substring(i,i+4));
                count++;
            }
        }
        System.out.println(count);
  }
}      
                                   ************************** 29th Problem *********************
/* 
Jelly is working on matrices, She likes to transform the matrices. This time, She is given a square matrix size n*n,and transforming the given matrix by rotating clockwise. 
For Example: 
	Given matrix size=3,  
	1 2 3 
	4 5 6 
	7 8 9 
	after rotating clockwise, matrix looks like: 
	7 4 1 
	8 5 2 
	9 6 3 
NOTE: Do not allocate another matrix and do the rotation. 
Input Format: 
Line-1: An integer n. 
Next N lines: n space separated integers. 
Output Format: 
Print the transformed Matrix. 
Sample Input-1: 
4 
5 1 9 11 
2 4 8 10 
13 3 6 7 
15 14 12 16 
Sample Output-1: 
15 13 2 5 
14 3 4 1 
12 6 8 9 
16 7 10 11 
1. For a NxN matrix,we need to N/2 cycles of swapping... 
2. In first cycle,Swap the elements of the first row with lastrow,and in the second cycle , 
	the 2nd  row with the 2nd last row are  to be swapped... and so on... 
3. Once the cycles are completed ,Using for loop transform the elements of  
	first row into first column,second row to second column and so on... 			 
4. Display the rotated image of the matrix. 
*/
// REVERSE ITERATION
import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int matrix[][] = new int[num][num];
        for(int i=0;i<num;i++)
        {
            for(int j=0;j<num;j++)
            {
                matrix[i][j] = sc.nextInt();
            }
        }
        for(int i=0;i<num;i++)
        {
            for(int j=num-1;j>=0;j--)
            {
                System.out.print(matrix[j][i] + " ");
            }
            System.out.println();
        }
    }
}                    
                                      ********************** 30th Problem *************************
/*Bob given a date in string form i.e, in the following format YYYY-MM-DD,  
print the day number int that year. 
Sample Input: date = "2018-01-10" 
Output: 10 
Explanation: Given date is the 10th day of the year 2018. 
Sample Input: date = "2018-02-11" 
Output: 42 
Note: 
date from Jan 1st, 1900 to Dec 31th, 2019.*/

import java.util.*;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String s1 = sc.nextLine();
        LocalDate a1 = LocalDate.parse(s1);
        int date = a1.getDayOfYear();
        System.out.println(date);
    }
}                             
                                      ************************* 31st Problem ********************
/*Ngit college decided to announce the toppers of 2nd year students , 
Here Management following a strategy to identify the toppers, i.e, 
They have three different set of lists with there roll numbers, 
first list is PS, second list is CS and third list is OUS.
They decided toppers of 2nd year as, the students those who are there in all three lists.
Note: lists are in sorted according to roll numbers.
Input:
1 2 3 4 5 6
2 5 7 8 9 10
1 2 4 5 8 11
Output:
2 5
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String str1 = sc.nextLine();
        String arr1[] = str1.split(" ");
        String str2 = sc.nextLine();
        String arr2[] = str2.split(" ");
        String str3 = sc.nextLine();
        String arr3[] = str3.split(" ");
        for(int i=0;i<arr1.length;i++)
        {
            for(int j=0;j<arr2.length;j++)
            {
                for(int k=0;k<arr3.length;k++)
                {
                    if(arr1[i].equals(arr2[j]) && arr2[j].equals(arr3[k]) && arr3[k].equals(arr1[i]))
                    {
                        System.out.println(arr1[i]+ " ");
                    }
                }
            }
        }
    }
}                            
                                  ************************** 32nd Problem ***************************
/*Write a function maxsubstring (str,alpha,theta) str is the source string and have to return maximum sub string which starts with alpha and ends with theta.
input=computer                                                                                                         
m                                                                                                                      
r    	
output=                                                                                                              
Max. Substring  is:mputer  
*/
import java.util.*;
class Test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char alpha = sc.next().charAt(0);
        char theta = sc.next().charAt(0);
        int start = str.indexOf(alpha);
        int end = str.lastIndexOf(theta);
        if(start == -1 || end == -1 || start > end)
        {
            System.out.println("No substring found");
        }
        else
        {
        System.out.println("Max. Substring is:" + str.substring(start,end+1));
        }
    }
}                          
                             **************************** 33rd Problem ****************************
 Maximum and minimum of an array using minimum number of comparisons

import java.util.*; 
class First 
{ 
    public static void main(String args[]) 
    { 
        Scanner sc = new Scanner(System.in); 
        System.out.println("Enter the size: "); 
        int n = sc.nextInt(); 
        int arr[] = new int[n]; 
        int max = 0; 
        int min = 0; 
        for(int i=0;i<n;i++) 
        { 
            arr[i] = sc.nextInt(); 
        } 
        min = arr[0]; 
        for(int i=0;i<n;i++) 
        { 
           if(arr[i]>max) 
           { 
            max = arr[i]; 
           } 
           if(arr[i]<=min) 
           { 
            min = arr[i]; 
           } 
        } 
        sc.close(); 
        System.out.println("Maximum element is: "+ max); 
        System.out.println("Minimum element is: "+ min); 
    } 
} 
                                ************************** 34th Problem *************************
/*Bob given two strings to jack, asking jack to comapre s1 and s2 to find are they following same sequence of pattern or not. if they are following print true otherwise false. 
baab 
rat mat mat rat 
Output: true 
Input:  
abba  
mat rat rat sat 
Output: false 
*/ 
import java.util.HashMap; 
import java.util.*; 
class Test 
{ 
    public static void main(String args[]) 
    { 
        Scanner sc = new Scanner(System.in); 
        String str1 = sc.nextLine(); 
        String str2 = sc.nextLine(); 
        String str2arr[] = str2.split(" "); 
        int len = str1.length(); 
        HashMap<Character, String> map = new HashMap<>(); 
        boolean match = true; 
        for(int i=0;i<len;i++) 
        { 
            char c = str1.charAt(i); 
            String s = str2arr[i]; 
            if(map.containsKey(c)) 
            { 
                if(!map.get(c).equals(s)) 
                { 
                    match = false; 
                    break; 
                } 
            } 
            else  
            { 
                if(map.containsValue(s)) 
                { 
                    match = false; 
                    break; 
                } 
            } 
            map.put(c,s); 
        } 
        System.out.println(match); 
    } 
}                
                             *********************** 35th Problem ************************     
/*Given a word consisting of lowercase characters from a to z, your task is to print the first character to emerge twice. 
A character a appears twice before another character b if the second occurrence 
of a is before the second occurrence of b. 
w will contain at least one character that emerge twice. 
sample1: 
Input: s = "baccadbbcz" 
Output: "c" 
Explanation: 
The character 'b' appears on the indexes 0, 6 and 7. 
The character 'a' appears on the indexes 1 and 4. 
The character 'c' appears on the indexes 2, 3 and 8. 
The character 'z' appears on the index 9. 
The character 'c' is the first character to emerge twice, 
because out of all the characters the index of its second occurrence is the smallest. 
sample 2: 
Input: s = "cbaee" 
Output: "e" 
Explanation: 
The only character that emerged twice is 'e' so we print 'e'. 
w consists of lowercase characters. 
w has at least one repeated character. 
*/ 

import java.util.*; 
import java.util.HashMap; 
class Test 
{ 
    public static void main(String args[]) 
    { 
         
        Scanner sc = new Scanner(System.in); 
        String s1 = sc.nextLine(); 
        char arr[] = s1.toCharArray(); 
        HashMap<Character, Integer> al = new HashMap<>(); 
        for(int i=0;i<s1.length();i++) 
        { 
            char c = arr[i]; 
            if(al.containsKey(c)) 
            { 
                System.out.println(c); 
                return; 
            } 
            al.put(c,i); 
        } 
    } 
}                                           
                                       *********************** 36th Problem ************************
/*Given a string, find size of palindrome with maximum length. alphabets are case sensitive, for example, "bB" is not considered a palindrome here.
Example 1:
Input: s = "abccccdd"
Output: 7
Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
Example 2:
Input: s = "a"
Output: 1
Explanation: The longest palindrome that can be built is "a", whose length is 1.
testcases:
case=1
input=abccccdd
output=7
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
       Scanner sc = new Scanner(System.in);
       String str = sc.nextLine();
       int len = 0;
       Set<Character> set = new HashSet<>();
       for(char c: str.toCharArray())
       {
           if(set.contains(c))
           {
               set.remove(c);
               len+=2;
           } else {
               set.add(c);
           }
       }
       if(!set.isEmpty())
       {
           len++;
       }
       System.out.println(len);
    }
}                           
                                   ************************* 37th Problem *************************
Reversing the Arrays

import java.util.*; 
public class Solutions { 
    public static void main(String[] args) { 
        Scanner sc = new Scanner(System.in); 
        System.out.println("Enter the size of the array:\n"); 
        int len = sc.nextInt(); 
        int arr[] = new int[len]; 
        int start = 0; 
        int end = len-1; 
        for (int i=0;i<len;i++) { 
            arr[i] = sc.nextInt(); 
        } 
        while(start < end) 
        { 
            int temp = arr[start]; 
            arr[start] = arr[end]; 
            arr[end] = temp; 
            start++; 
            end--; 
        } 
        for (int i = 0; i < len; i++) { 
            System.out.println(arr[i]); 
        } 
        sc.close(); 
    } 
}        
CONTAINS DUPLICATE ELEMENTS  IN AN ARRAY OR NOT..
class Solution { 
    public boolean containsDuplicate(int[] nums) { 
       Arrays.sort(nums); 
       for(int i=0;i<nums.length-1;i++) 
       { 
           if(nums[i] == nums[i+1]) 
           { 
               return true; 
           } 
       } 
       return false; 
    } 
}
                             ************************** 38th Problem ************************
/*A string is given. identify the numbers of instances possible for the word "student"
You can use each character in the string at most once. Return the total number of instances that can be formed.
Explanation1:
input=escsceca
output=2
from the given string, the word "cse" can be formed twice
Explanation2:
input=asceasdf
output=1
Testcases:
case=1
input=escsceca
output=2
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        char[] st = s.toCharArray();
        Map<Character,Integer> mp = new HashMap<>();
        for(int i=0;i<st.length;i++)
        {
            if(mp.containsKey(st[i]))
            {
                int a = mp.get(st[i]);
                mp.put(st[i],a+1);
            }
            else {
                mp.put(st[i],1);
            }
        }
        int out=0;
        int min=0;
        for(Map.Entry<Character,Integer> me:mp.entrySet())
        {
            char d = me.getKey();
            if(d=='c' || d=='s' || d=='e')
            {
                out = me.getValue();
                if(out<min)
                {
                    out = min;
                }
            }
        }
        System.out.print(out);
    }
}
                            ************************* 39th Problem **********************
 /*You are given list of numbers. find the sum of numbers that appear exactly once in the list.
Example 1:
Input: nums = [1,2,3,2]
Output: 4
Explanation: The non repeating numbers are [1,3], and the sum is 4.
Example 2:
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no non-repeating numbers, and the sum is 0.
Example 3:
Input: nums = [1,2,3,4,5]
Output: 15
Explanation: The non repeating numbers are [1,2,3,4,5], and the sum is 15.
Testcases:
case=1
input=1 2 3 2
output=4
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String[] sa = s.split(" ");
        Map<String, Integer> mp = new HashMap<>();
        for(int i=0;i<sa.length;i++)
        {
            if(mp.containsKey(sa[i]))
            {
                int a = mp.get(sa[i]);
                mp.put(sa[i],a+1);
            }
            else {
                mp.put(sa[i],1);
            }
        }
        int sum = 0;
        for(Map.Entry<String, Integer> me:mp.entrySet())
        {
            if(me.getValue() == 1)
            {
                int d = Integer.parseInt(me.getKey());
                sum = sum+d;
            }
        }
        System.out.println(sum);
    }
}                        
                                ********************** 40th Problem *************************
/*You are given the array of routes, where route[i] = [stateAi, stateBi] means there exists a direct path 
going from stateAi to stateBi. Return the destination state, that is, the state without any route outgoing 
to another state.
It is guaranteed that the graph of routes forms a line without any loop, therefore, 
there will be exactly one destination city.
Example 1:
Input: routes = [["telangana","andhrapradesh"],["andhrapradesh","tamilnadu"],["tamilnadu","kerala"]]
Output: "kerala" 
Explanation: Starting at "telangana" state you will reach "kerala" state which is the destination city. 
Your trip consist of: "telangana" -> "andhrapradesh" -> "tamilnadu" -> "kerala".
Example 2:
Input: routes = [["ladakh","jammu"],["punjab","delhi"],["jammu","punjab"]]
Output: "delhi"
Explanation: All possible trips are: 
"ladakh" -> "jammu" -> "punjab" -> "delhi". 
"jammu" -> "punjab" -> "delhi"
"punjab" -> "delhi"
"delhi"
Clearly the destination state is "A".
Example 3:
Input: routes = [["telangana","maharashtra"]]
Output: "maharashtra"
testcases:
case=1
input=telangana,andhrapradesh,andhrapradesh,tamilnadu,tamilnadu,kerala
output=kerala
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String[] routes = input.split(",");
        ArrayList<String> destinations = new ArrayList<String>();
        for(int i=1;i<routes.length;i+=2)
        {
            destinations.add(routes[i]);
        }
        for(int i=0;i<routes.length;i+=2)
        {
            destinations.remove(routes[i]);
        }
        String destinationState = destinations.get(0);
        System.out.println(destinationState);
}
}                     
                                        ************************ 41st Problem ***********************
/*There are n Circles and each Circle is either pink, Yellow, or White. The Circles are distributed across ten poles labeled from 0 to 9. 
You are given a string Circles of length 2n that describes the n Circles that are placed onto the poles. Every two characters in Circles forms a color-position pair that is used to describe each Circle where: 
The first character of the ith pair denotes the ith Circles color ('P', 'Y', 'W'). 
The second character of the ith pair denotes the pole that the ith Circle is placed on ('0' to '9'). 
For example, "P3Y2W1" describes n == 3 Circles : a pink Circle placed onto the pole labeled 3, a Yellow Circle placed onto the pole labeled 2, and a White Circle placed onto the pole labeled 1. 
Return the number of poles that have all three colors of Circles on them. 
Example: 
Input: input = "W0W6Y0P6P0P6Y9" 
Output: 1 
Explanation:  
- The pole labeled 0 holds 3 Circles with all colors: pink, yellow, and white. 
- The pole labeled 6 holds 3 Circles , but it only has pink and white. 
- The pole labeled 9 holds only a yellow Circle. 
Thus, the number of poles with all three colors is 1. 
*/ 

import java.util.*; 
class Test 
{ 
    public static void main(String args[]) 
    { 
        Scanner sc = new Scanner(System.in); 
        String str = sc.nextLine(); 
        int count = 0; 
        HashSet<Character> hs = new HashSet<>(); 
        for(int i=0;i<=9;i++) 
        { 
            for(int j=0;j<str.length();j++) 
            { 
                if((str.charAt(j)-48)==i) 
                    hs.add(str.charAt(j-1)); 
            } 
                if(hs.size()==3) 
                count++; 
                hs.clear(); 
        } 
        System.out.println(count); 
    } 
}                     
                                *********************** 42nd Problem ************************
/*Given set of nodes like [2,1,1,2] , using them form a singly linked list,  
left node in the linked list represents MSB and right node  in the linked list represents LSB, 
where 2 is MSB and 2 is LSB. 
by using above nodes you can form singly linked list like 2-->1-->1-->2. 
your task is to print yes if it is palindrome otherwise print no. 
Examples: 
input=2,1,1,2 
output=yes 
input=2,1 
output=no 
*/ 

import java.util.*; 
class Test 
{ 
    public static void main(String args[]) 
    { 
        Scanner sc = new Scanner(System.in); 
        String s = sc.nextLine(); 
        String str[] = s.split(","); 
        LinkedList <Integer> ll = new LinkedList<Integer>(); 
        for(int i=0;i<str.length;i++) 
        { 
            ll.add(Integer.parseInt(str[i])); 
        } 
        LinkedList<Integer> ll1 = new LinkedList<Integer> (); 
        for(int i=str.length-1;i>=0;i--) 
        { 
            ll1.add(Integer.parseInt(str[i])); 
        } 
        if(ll.equals(ll1)) 
        { 
            System.out.println("yes"); 
        } 
        else { 
            System.out.println("no"); 
        } 
         
    } 
}                                
                                ********************** 42nd Problem **************************
/*You are given an array of numbers. the following can be done in single iteration:
1. select two equal numbers.
2. delete both of them from the array.
3. repeat steps 1 & 2 until there is no equal numbers available in the array.
return the number of pairs deleted and leftover elements in the array
Example 1:
Input: [1,3,2,1,3,2,2]
Output: [3,1]
Explanation:
first 1,1 will be selected and deleted, resulting array = [3,2,3,2,2].
then 3,3 will be selected and deleted, resulting array= [2,2,2].
then 2,2 will be selected and deleted, resulting array= [2].
No more pairs can be formed. A total of 3 pairs deleted, and there is 1 number leftover in nums.
Example 2:
Input: [1,1]
Output:[1,0]
Explanation: first 1,1 will be selected and deleted, resulting array= [].
No more pairs can be formed. A total of 1 pair deleted, and there are 0 numbers leftover in the array.
Example 3:
Input: [0]
Output: [0,1]
Explanation: No pairs can be formed, and there is 1 number leftover in the array.
Testcases:
case=1
input=1,3,2,1,3,2,2
output=3,1
*/

import java.util.*;
class test
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        String[] arr = sc.nextLine().split(",");
        int n = arr.length;
        int[] nums = new int[n];
        for(int i=0;i<n;i++)
        {
            nums[i] = Integer.parseInt(arr[i]);
        }
        int count=0;
        for(int i=0;i<n;i++)
        {
            if(nums[i] == -1)
            {
                continue;
            }
            for(int j=i+1;j<n;j++)
            {
                if(nums[j] == -1)
                {
                    continue;
                }
                if(nums[i] == nums[j])
                {
                    nums[i] = -1;
                    nums[j] = -1;
                    count++;
                    break;
                }
            }
        }
        int c1=0;
        for(int i=0;i<n;i++)
        {
            if(nums[i] != -1)
            {
                c1++;
            }
        }
        System.out.println(count+","+c1);
    }
}                                
                                ********************** 43rd Problem *************************